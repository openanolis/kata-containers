// Copyright (c) 2019-2022 Alibaba Cloud
// Copyright (c) 2019-2022 Ant Group
//
// SPDX-License-Identifier: Apache-2.0
//

use crate::{
    device_type::{BlockDevice, Device, DeviceArgument, GenericConfig, GenericDevice},
    get_device_type, DeviceType, Hypervisor,
};

use anyhow::{anyhow, Context, Result};
use ini::Ini;
use kata_sys_util::rand;
use std::{collections::HashMap, sync::Arc};
use tokio::sync::Mutex;

pub type ArcBoxDevice = Arc<Mutex<Box<dyn Device>>>;
const SYS_DEV_PREFIX: &str = "/sys/dev";

/// VIRTIO_BLOCK_MMIO indicates block driver is virtio-mmio based
pub const VIRTIO_BLOCK_MMIO: &str = "virtio-blk-mmio";
/// VIRTIO_BLOCK_PCI indicates block driver is virtio-pci based
pub const VIRTIO_BLOCK_PCI: &str = "virtio-blk-pci";
pub const KATA_MMIO_BLK_DEV_TYPE: &str = "mmioblk";
pub const KATA_BLK_DEV_TYPE: &str = "blk";
// VFIO device to be bound to vfio-pci and made available inside the
// container as a VFIO device node
pub const KATA_VFIO_DEV_TYPE: &str = "vfio-pci";
pub const VFIO_DEVICE_PCI: &str = "vfio-pci";
// the default start block index for block(e.g vdb) is 1,
// and the index 0 for vda usually for root disk.
const DEFAULT_START_BLOCK_INDEX: u64 = 1;

// block_index and released_block_index are used to search an available block index
// in Sandbox.
//
// @block_index generally default is 1 for <vdb>;
// @released_block_index for blk devices removed and indexes will released at the same time.
#[derive(Clone, Debug, Default)]
struct SharedInfo {
    block_index: u64,
    released_block_index: Vec<u64>,
}

impl SharedInfo {
    fn new(index: u64) -> Self {
        SharedInfo {
            block_index: index,
            released_block_index: vec![],
        }
    }

    // declare the available block index
    fn declare_device_index(&mut self) -> Result<u64> {
        let current_index = if let Some(index) = self.released_block_index.pop() {
            index
        } else {
            self.block_index
        };
        self.block_index += 1;

        Ok(current_index)
    }

    fn release_device_index(&mut self, index: u64) {
        self.released_block_index.push(index);
        self.released_block_index.sort_by(|a, b| b.cmp(a));
    }
}

#[derive(Clone)]
pub struct DeviceManager {
    pub devices: HashMap<String, Arc<Mutex<Box<dyn Device>>>>,
    hypervisor: Arc<dyn Hypervisor>,
    shared_info: SharedInfo,
}

impl DeviceManager {
    pub async fn new(hypervisor: Arc<dyn Hypervisor>) -> Result<Self> {
        let devices = HashMap::<String, Arc<Mutex<Box<dyn Device>>>>::new();

        Ok(DeviceManager {
            devices,
            hypervisor,
            shared_info: SharedInfo::new(DEFAULT_START_BLOCK_INDEX),
        })
    }

    pub async fn new_device(&mut self, device: &oci::LinuxDevice) -> Result<String> {
        // generate device config from oci spec
        let mut device_info = self
            .new_device_info_from_oci(device, None)
            .context("failed to generate device config from oci spec")?;

        // register device into device manager and return device_id
        let device_id = self.try_add_device(&mut device_info).await?;

        Ok(device_id)
    }

    pub async fn try_add_device(&mut self, dev_info: &mut GenericConfig) -> Result<String> {
        // if the device is already created, just return the device
        if let Some(dev) = self
            .find_device(
                dev_info.major,
                dev_info.minor,
                dev_info.host_path.as_str(),
                dev_info.bdf.clone(),
            )
            .await
        {
            return Ok(dev.lock().await.device_id().await.to_string());
        }

        // device ID must be generated by manager instead of device itself
        // in case of ID collision
        dev_info.id = self.new_device_id()?;

        // check the valid device number
        if dev_info.major >= 0 && dev_info.minor >= 0 {
            // find /dev/xxxx
            let path = get_host_path(dev_info)?;
            dev_info.host_path = path;
        }

        let dev: ArcBoxDevice = match get_device_type(dev_info) {
            DeviceType::Block => {
                let block_driver = self
                    .hypervisor
                    .hypervisor_config()
                    .await
                    .blockdev_info
                    .block_device_driver;

                let blk_driver = match block_driver.as_str() {
                    VIRTIO_BLOCK_MMIO => KATA_MMIO_BLK_DEV_TYPE.to_string(),
                    VIRTIO_BLOCK_PCI => KATA_BLK_DEV_TYPE.to_string(),
                    _ => "".to_string(),
                };

                // driver_options for driver info
                dev_info
                    .driver_options
                    .insert("block-driver".to_owned(), blk_driver);

                Arc::new(Mutex::new(Box::new(BlockDevice::new(dev_info))))
            }
            DeviceType::Vfio => {
                // TODO: do something for vfio device
                todo!()
            }
            _ => Arc::new(Mutex::new(Box::new(GenericDevice::new(dev_info)))),
        };

        // dev_id is same as dev_info.id
        let need_skip = dev
            .lock()
            .await
            .increase_attach_count()
            .await
            .context("failed to increase attach count")?;
        // we need to skip the device, if the device is already attached
        if need_skip {
            return Ok(dev_info.id.clone());
        }

        // register device (arcboxdevice)
        self.devices.insert(dev_info.id.clone(), dev.clone());

        let da = self
            .make_device_argument(dev_info.dev_type.as_str())
            .context("failed to make device arguments")?;

        // We will finally call the concrete device attach operation
        dev.lock()
            .await
            .attach(self.hypervisor.as_ref(), da.clone())
            .await?;

        // TODO: we need to handle the failure of attachment, Currently, however we cannot capture
        // useful error message from attach as the result of its return Result<()>

        Ok(dev_info.id.clone())
    }

    pub async fn try_remove_device(&mut self, device_id: String) -> Result<()> {
        // First of all, we need find the device with device_id
        if let Some(dev) = self.get_device_by_id(&device_id).await {
            // caculate the count of device detached, Once it reaches the 0, skip it.
            let need_skip = dev.lock().await.decrease_attach_count().await?;
            if need_skip {
                info!(sl!(), "device attach' counter decreased to 0, skip it");
                return Ok(());
            }

            // do detach and release the declared device index
            if let Some(index) = dev.lock().await.detach(self.hypervisor.as_ref()).await? {
                self.shared_info.release_device_index(index);
            }

            // remove the record from DeviceManager
            self.devices.remove(&device_id);
        }

        Ok(())
    }

    pub async fn get_device_info_by_id(&self, device_id: &str) -> Option<GenericConfig> {
        // First of all, we need find the device with device_id
        if let Some(device) = self.get_device_by_id(device_id).await {
            if let Ok(dev_info) = device.lock().await.get_device_info().await {
                return Some(dev_info);
            }
        }
        None
    }

    pub async fn get_device_vm_path(&self, device_id: &str, field_type: &str) -> Option<String> {
        if let Some(dev_info) = self.get_device_info_by_id(device_id).await {
            return match field_type {
                KATA_BLK_DEV_TYPE => dev_info.bdf,
                _ => dev_info.virt_path,
            };
        }

        None
    }

    pub async fn get_driver_options(&self, device_id: &str) -> Result<String> {
        // do refactor later
        if let Some(dev_info) = self.get_device_info_by_id(device_id).await {
            if let Some(driver) = dev_info.driver_options.get("block-driver") {
                return Ok(driver.clone());
            }

            // TODO: add something for VFIO/VhostUser ... device
        }

        Err(anyhow!("get driver options failed."))
    }

    // device ID must be generated by device manager instead of device itself
    // in case of ID collision
    fn new_device_id(&self) -> Result<String> {
        for _ in 0..5 {
            let rand_bytes = rand::RandomBytes::new(8);
            let id = format!("{:x}", rand_bytes);

            // check collision in devices
            if self.devices.get(&id).is_none() {
                return Ok(id);
            }
        }

        Err(anyhow!("ID are exhausted"))
    }

    // prepare arguments to attach device
    fn make_device_argument(&mut self, dev_type: &str) -> Result<DeviceArgument> {
        if dev_type == "b" {
            let current_index = self.shared_info.declare_device_index()?;
            let drive_name = self.get_virt_drive_name(current_index as i32)?;

            Ok(DeviceArgument {
                index: Some(current_index),
                drive_name: Some(drive_name),
            })
        } else {
            Ok(DeviceArgument {
                index: None,
                drive_name: None,
            })
        }
    }

    async fn find_device(
        &self,
        major: i64,
        minor: i64,
        host_path: &str,
        bdf: Option<String>,
    ) -> Option<ArcBoxDevice> {
        for dev in self.devices.values() {
            if dev.lock().await.get_host_path().await == host_path {
                return Some(dev.clone());
            }

            if dev.lock().await.get_bdf().await == bdf.as_ref() {
                return Some(dev.clone());
            }

            let mm = dev.lock().await.get_major_minor().await;
            if mm.0 == major && mm.1 == minor {
                return Some(dev.clone());
            }
        }

        None
    }

    async fn get_device_by_id(&self, id: &str) -> Option<ArcBoxDevice> {
        self.devices.get(id).map(Arc::clone)
    }

    pub fn new_device_info_from_oci(
        &self,
        device: &oci::LinuxDevice,
        bdf: Option<String>,
    ) -> Result<GenericConfig> {
        info!(sl!(), "Linux device info: {:?}", device);
        // b      block (buffered) special file
        // c, u   character (unbuffered) special file
        // p      FIFO
        // refer to https://man7.org/linux/man-pages/man1/mknod.1.html
        let allow_device_type: Vec<&str> = vec!["c", "b", "u", "p"];

        if !allow_device_type.contains(&device.r#type.as_str()) {
            return Err(anyhow!("runtime not support device type {}", device.r#type));
        }

        if device.path.is_empty() {
            return Err(anyhow!("container path can not be empty"));
        }

        let file_mode = device.file_mode.unwrap_or(0);
        let uid = device.uid.unwrap_or(0);
        let gid = device.gid.unwrap_or(0);

        let dev_info = GenericConfig {
            host_path: String::new(),
            container_path: device.path.clone(),
            dev_type: device.r#type.clone(),
            major: device.major,
            minor: device.minor,
            file_mode,
            uid,
            gid,
            id: "".to_string(),
            bdf,
            driver_options: HashMap::new(),
            ..Default::default()
        };
        Ok(dev_info)
    }

    // get_virt_drive_name returns the disk name format for virtio-blk
    // Reference: https://github.com/torvalds/linux/blob/master/drivers/block/virtio_blk.c @c0aa3e0916d7e531e69b02e426f7162dfb1c6c0
    fn get_virt_drive_name(&self, mut index: i32) -> Result<String> {
        if index < 0 {
            return Err(anyhow!("Index cannot be negative"));
        }

        // Prefix used for virtio-block devices
        const PREFIX: &str = "vd";

        // Refer to DISK_NAME_LEN: https://github.com/torvalds/linux/blob/08c521a2011ff492490aa9ed6cc574be4235ce2b/include/linux/genhd.h#L61
        let disk_name_len = 32usize;
        let base = 26i32;

        let suff_len = disk_name_len - PREFIX.len();
        let mut disk_letters = vec![0u8; suff_len];

        let mut i = 0usize;
        while i < suff_len && index >= 0 {
            let letter: u8 = b'a' + (index % base) as u8;
            disk_letters[i] = letter;
            index = (index / base) - 1;
            i += 1;
        }
        if index >= 0 {
            return Err(anyhow!("Index not supported"));
        }
        disk_letters.truncate(i);
        disk_letters.reverse();
        Ok(String::from(PREFIX) + std::str::from_utf8(&disk_letters)?)
    }
}

// get_host_path is used to fetch the host path for the device.
// The path passed in the spec refers to the path that should appear inside the container.
// We need to find the actual device path on the host based on the major-minor numbers of the device.
pub(crate) fn get_host_path(dev_info: &GenericConfig) -> Result<String> {
    if dev_info.container_path.is_empty() {
        return Err(anyhow!("Empty path provided for device"));
    }

    let path_comp = match dev_info.dev_type.as_str() {
        "c" | "u" => "char",
        "b" => "block",
        // for device type p will return an empty string
        _ => return Ok(String::new()),
    };
    let format = format!("{}:{}", dev_info.major, dev_info.minor);
    let sys_dev_path = std::path::Path::new(SYS_DEV_PREFIX)
        .join(path_comp)
        .join(format)
        .join("uevent");
    if let Err(e) = std::fs::metadata(&sys_dev_path) {
        // Some devices(eg. /dev/fuse, /dev/cuse) do not always implement sysfs interface under /sys/dev
        // These devices are passed by default by docker.
        // Simply return the path passed in the device configuration, this does mean that no device renames are
        // supported for these devices.
        if e.kind() == std::io::ErrorKind::NotFound {
            return Ok(dev_info.container_path.clone());
        }
        return Err(e.into());
    }
    let conf = Ini::load_from_file(&sys_dev_path)?;
    let dev_name = conf
        .section::<String>(None)
        .ok_or_else(|| anyhow!("has no section"))?
        .get("DEVNAME")
        .ok_or_else(|| anyhow!("has no DEVNAME"))?;
    Ok(format!("/dev/{}", dev_name))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dragonball::Dragonball;
    use crate::HypervisorConfig;

    #[actix_rt::test]
    async fn test_get_virt_drive_name() {
        let mut hypervisor = Dragonball::new();
        let mut config = HypervisorConfig::default();
        config.blockdev_info.block_device_driver = "virtio-blk-mmio".to_string();
        hypervisor.set_hypervisor_config(config).await;
        let manager = DeviceManager::new(Arc::new(hypervisor)).await.unwrap();
        for &(input, output) in [
            (0i32, "vda"),
            (25, "vdz"),
            (27, "vdab"),
            (704, "vdaac"),
            (18277, "vdzzz"),
        ]
        .iter()
        {
            let out = manager.get_virt_drive_name(input).unwrap();
            assert_eq!(&out, output);
        }
    }
}
